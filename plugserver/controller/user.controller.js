/**
 * Created by evgenijavstein on 03/06/15.
 */

var YAML = require('yamljs'),
    crypto = require('crypto'),
    User = require('./../model/user.js'),
    helper = require('./../controller/helper');
validator = require('node-validator');
userConfig = YAML.load('users.yaml');

exports.sendAuthenticatedUser=function(req,res){
    var user=clone(req.user);
    //remove sensitive information
    delete user.password;
    delete user.salt;
    res.send(user);
}

/**
 * Authenticates user by comparing password hashes using the salt generated by user creation
 * @param login
 * @param password
 * @returns {boolean}
 */
exports.authenticateUser = function (login, password) {
    var user = exports.findUser(login);
    if (user) {
        //create password hash with same salt if equal then the password provided was correct
        return user.password === createPasswordHash(password, user.salt);
    }
    return false;
}
/**
 * Method checks  if user is admin, assumes the user to be authenticated, which means
 * a user reference is in the request
 * @param req
 * @param res
 * @returns {boolean}
 */
exports.isAdmin = function (req,res,next) {
    var user = exports.findUser(req.user.login);
     if(user.role === 'admin'){
         next();
     }else{
         res.status(400).send({message:"No permission: you need to be admin to perfrom this."});
     }
}
/**
 * Adds a user is valid user data was provided.
 * Password is not stored, but a diggest of the password. Salt is used.
 * @param req
 * @param res
 */
exports.addUser = function (req, res,next) {

    //should validate here first

    var newUser = new User(req.body);
    var oldUser = exports.findUser(newUser.login);
    if (false) {
        res.status(400).send({message: "login already taken"});
    } else {
        var check = validator.isObject()
            .withRequired('login', validator.isString({regex: /^[a-z ,.'-]+$/i}))
            .withRequired('first_name', validator.isString({regex: /^[a-z ,.'-]+$/i}))
            .withRequired('last_name', validator.isString({regex: /^[a-z ,.'-]+$/i}))
            .withRequired('role', validator.isString({regex: /(admin|user)$/}))
            .withRequired('password', validator.isString({regex: /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{5,}$/}))
            .withOptional('salt');

        validator.run(check, newUser, function (errorCount, errors) {
            if (errorCount == 0) {
                //never store a password, but it's hash
                newUser.salt = generateSaltString();
                newUser.password = createPasswordHash(newUser.password, newUser.salt);

                userConfig.users.push(newUser);
                //persist state of user list
                helper.saveFile(YAML.stringify(userConfig, 4), "/../users.yaml");
                res.send(newUser);
            } else {

                res.status(400).send({message: "user data provided is not valid", errors: errors});
            }


        });


    }


}
/**
 * Removes users by login, except admin, which is initial user and cannot be removed
 * @param req
 * @param res
 */
exports.removeUser = function (req, res) {
    var login = req.body.login;
    if (login != 'admin') {
        var removedUser = exports.findUser(login);
        if (removedUser) {
            var index = userConfig.users.indexOf(removedUser);
            userConfig.users.splice(index, 1);
            helper.saveFile(YAML.stringify(userConfig, 4), "/../users.yaml");
            res.send(removedUser);
        } else {
            res.status(400).send({message: "there is no such user"})
        }


    } else {
        res.status(400).send({message: "admin cannot be removed"});
    }

}
/**
 * Find user by login, login used as unique id here
 * @param login
 * @returns {*}
 */
exports.findUser=function(login) {
    for (var i = 0; i < userConfig.users.length; i++) {
        if (userConfig.users[i].login == login) {
            return userConfig.users[i];
        }
    }
}
/***
 * To generate random salt base64 string
 * @param password
 * @returns {string|*}
 */
function generateSaltString() {
    return new Buffer(crypto.randomBytes(16).toString('base64'), 'base64').toString('base64');
}
/**
 *
 * Mixes password and salt (Pseudo random buffer) to a hash and returns it
 * as base64 string.
 * PBKDF2 is the key derivation function from RSA Labaratories, which makes password cracking more difficult.
 * @param password
 * @param salt
 * @returns {string|*}
 */
function createPasswordHash(password, salt) {
    var buffer = new Buffer(salt, 'base64')
    return crypto.pbkdf2Sync(password, buffer, 10000, 64).toString('base64');
}

function clone(a) {
    return JSON.parse(JSON.stringify(a));
}